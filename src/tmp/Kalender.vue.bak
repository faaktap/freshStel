<template>
<v-container fluid class="ma-0 pa-0">
 <base-tool :toolList="[]"
            toolbarName="DEKHS CALENDAR"
           :loading="loading"
            >
            <v-btn icon title="Possible printing?" @click="() => {alert('ddd')}">
            E
           </v-btn>
</base-tool>

  <v-row>
    <v-col>
    <v-sheet tile height="44">
    <v-toolbar flat dense :loading="loading" class="ma-2 pa-2">
     <v-row>
      <v-col cols=1>
        <v-btn icon class="ma-2" @click="$refs.calendar.prev()">
          <v-icon>mdi-chevron-left</v-icon>
        </v-btn>
      </v-col>
      <v-col cols=4>
        <v-btn x-small class="ma-2" color="primary" @click="setToday">
            Today
        </v-btn>
      </v-col>
      <v-col cols=3>
        <v-toolbar-title v-if="$refs.calendar">
            {{ $refs.calendar.title }}
        </v-toolbar-title>
      </v-col>
      <v-col cols=3 class="text-right">
         <!-- <v-btn align="right" class="ma-2" small color="primary" @click="weekOrDayChange">  {{ weekOrDay }} </v-btn> -->
         <v-btn-toggle small v-model="toggleView" >
         <v-btn class="ma-0" x-small xicon color="primary" @click="weekOrDay = 'day'">day</v-btn>
         <v-btn class="ma-0" x-small xicon color="primary" @click="weekOrDay = 'week'">Week</v-btn>
         <v-btn class="ma-0" x-small xicon color="primary" @click="weekOrDay = 'month'">Month</v-btn>
         </v-btn-toggle>
      </v-col>
      <v-col cols=1>
        <v-btn icon class="ma-2" @click="$refs.calendar.next()">
          <v-icon>mdi-chevron-right</v-icon>
        </v-btn>
       </v-col>
     </v-row>
    </v-toolbar>
    </v-sheet>
    <v-sheet height="800">
        <!-- overlap is stack or column -->
        <v-calendar
          dense
          v-if="events.length > 0"
          ref="calendar"
          v-model="calValue"
          :now="calToday"
          :value="calToday"
          :events="events"
          :weekdays="weekday"
          event-color="secondary"
          event-overlap-mode="stack"
          color="primary"
          :type="weekOrDay"
          first-time="06:30"
          :interval-format="intervalFormat"
          intervalMinutes="60"
          interval-count="20"
          interval-height="55"
          interval-minutes="30"
          short-intervals
          show-month-on-first
          @change="updateRange"
          @click:event="clickEvent"
          @click:more="clickMore"
          @click:date="clickDate"
          @click:day="clickDay"
          @click:day-category="clickDayCategory"
          @click:interval="clickInterval"
          @click:time="clickTime"

        > <!-- weekdays=[1,2,3,4,5,6,0] -->
         <!-- <template v-slot:day-body="{ date, week }">
            <div
               class="v-current-time"
              :class="{ first: date === week[0].date }"
              :style="{ top: nowY }"
            >
            </div>
         </template> -->


        </v-calendar>


<!---  SELECTED EVENT --->
        <v-menu
          v-model="selectedOpen"
          :close-on-content-click="true"
          :activator="selectedElement"
          offset-x
        >
          <v-card color="blue-grey lighten-4" min-width="350px" flat>
            <v-toolbar color="selectedEvent.color">
              <v-btn icon> <v-icon>mdi-pencil</v-icon> </v-btn>
              <v-toolbar-title v-if="selectedEvent">
                {{ showEvtNameAndTime }}
              </v-toolbar-title>
            </v-toolbar>
            <v-card-text>
              <span v-if="selectedEvent" v-html="selectedEvent"></span>
            </v-card-text>
            <v-card-actions>
              <!-- <v-btn small text color="secondary" @click="clickLoad" > load </v-btn> -->
              <v-btn small text color="secondary" @click="selectedOpen = false">Close</v-btn>
            </v-card-actions>
          </v-card>
        </v-menu>
     </v-sheet>
    </v-col>
  </v-row>
<v-dialog v-model="showEvent" width="455px" height="100%" scrollable color="red">
  <event-form @close="showEvent = false" :eventDetails="selectedEvent"/>
</v-dialog>

<v-container fluid v-if="getZml.login.superUser">
 <base-title-expand  heading="TestCal1">
  <test-cal-1 />
 </base-title-expand>

 <base-title-expand  heading="TestCal2">
  <test-cal-2 />
 </base-title-expand>

 <base-title-expand  heading="Periods">
  <period-table />
 </base-title-expand>

 <base-title-expand  heading="TestCal3">
  <test-cal-3 />
 </base-title-expand>

 <base-title-expand  heading="All Events">
    <v-card>
      <v-card-title><h4> Only Werner - this is all the events (Periods, Days, Holidays and Birthdays)</h4> </v-card-title>
      <v-card-text>
         <v-data-table
           :headers="eventHeaders"
           :items="events"
           class="elevation-1"
           multi-sort
         />
      </v-card-text>
   </v-card>
 </base-title-expand>
  </v-container>
        <!-- <v-btn  @click="checkChange"> R(CC) </v-btn> -->
</v-container>
</template>

<script>
//import { format         ,lastDayOfMonth        , addYears } from 'date-fns'
import { getters } from "@/api/store"
import { zDate } from '@/api/zDate.js'
//import { zData } from '@/api/zGetBackgroundData.js'
import { zmlConfig } from '@/api/constants.js';
import { zmlFetch } from '@/api/zmlFetch.js';
import baseTool from '@/components/base/baseTool.vue'
import BaseTitleExpand from '@/components/base/BaseTitleExpand.vue'
import PeriodTable from '@/components/cal/PeriodTable.vue'
import TestCal1 from '@/components/cal/TestCal1.vue'
import TestCal2 from '@/components/cal/TestCal2.vue'
import TestCal3 from '@/components/cal/TestCal3.vue'
import EventForm from '@/components/cal/EventForm.vue'
export default {
  name: 'Kalendar',
  components: {baseTool
             , BaseTitleExpand
             , PeriodTable
             , EventForm
             , TestCal1
             , TestCal2
             , TestCal3
  },
  data: () => ({
      getZml: getters.getState({ object: "gZml" }),
      loading:false,
      today: null,
      calToday: null,
      calValue: '',
      calReady: false,
      events:[{ start: "1900-01-01", name: "" }],
      eventHeaders: [{value: 'name', text: 'desc'}
                  ,  {value: 'detail', text:'det'}
                  ,  {value: 'length', text:'len'}
                  ,  {value: 'start', text:'startdate'}
                  ,  {value: 'end', text:'endtime'}
                  ,  {value: 'color'}
                  ,  {value: 'type', text:'pname'}
                  ,  {value: 'timed'}, {value: 'id'}],
      selectedEvent: null,
      selectedElement: null,
      selectedOpen: null,
      personeelMenemonic: '',
      weekOrDay:'week',
      weekday:[1, 2, 3, 4, 5, 6, 0],
      weekdays: [
        { text: 'Sun - Sat', value: [0, 1, 2, 3, 4, 5, 6] },
        { text: 'Mon - Sun', value: [1, 2, 3, 4, 5, 6, 0] },
        { text: 'Mon - Fri', value: [1, 2, 3, 4, 5] },
        { text: 'Mon, Wed, Fri', value: [1, 3, 5] }],
      showEvent: false,
      toggleView: 1,
  }),
  computed: {
      intervalFormat(locale, getOptions) {
        console.log('----------------------------------',locale, getOptions)
        return locale.time
      },
      showEvtNameAndTime() {
        //Show vue component...console.log('showEvtNameAndTime::e::',e)
        //Show the actual event date,name,color etc..: console.log('showEvtNameAndTime::E::',this.selectedEvent)
        //<span event-summry... etc.. console.log('showEvtNameAndTime::El::',this.selectedElement)
        //stuff..console.log('showEvtNameAndTime::El-Span::',JSON.stringify(this.selectedElement))
        //null - console.log('showEvtNameAndTime::Op::',this.selectedOpen)
        console.log(  `<div color="${this.selectedEvent.color}"> ${this.selectedEvent.name}  <small> ${this.selectedEvent.start} </small></div>`)
        //can return stuff based on this.selectedEvent.name
        return `${this.selectedEvent.detail}`
      },
      sortIt() {
        let cal = this.getZml.calendar.filter(item => item.type == 'School')
        // console.log(this.getZml.calendar,cal)
        return cal.sort((a,b) => a.startdate - b.startdate)
      },

      cal () {
        return this.calReady ? this.$refs.calendar : null
      },
      nowY () {
        return this.cal ? this.cal.timeToY(this.cal.times.now) + 'px' : '-10px'
      },
    },

  methods:{
  //click:date The click event on the day of the month link. The event passed is the day & time object. Native mouse event is passed as a second argument.
  //click:day	 The click event on a day. The event passed is the day object. Native mouse event is passed as a second argument.
  //click:day-category	The click event on a day in the category view. The event passed is the day object. Native mouse event is passed a 2nd
  //click:event	The click event on a specific event. The event passed is the day & time object. see https://v2.vuetifyjs.com/en/api/v-calendar/#events
  //click:interval The click event at a specific interval label in the day view. The event passed is the day & time object. Native mou
  //click:more	The click event on the X more button on views with too many events in a day. Native mouse event is passed as
  //click:time	The click event at a specific time in the day view. The event passed is the day & time object. Native mouse event is
      clickTime ({ date,past,future, hasTime, hour, minute }) {
        //-------------------------------------------------------------------------
        // Here we are clicking on an empty part of the calendar, but underneath a day
        // So we can assume they want to add an event : we have a day and a time
        // We should ALWAYS have a time in here!
        //-------------------------------------------------------------------------
        console.log('-----------clicked on aTIME in Day View, week view, mo', date, 'past=',past,'fut=',future, 'hasT',hasTime)
        if (this.showEvent == true) return //we handled it already
        if (past == true) {
          console.log('you want to add an event in the past?')
        }
        this.createBlankEvent(date, hasTime, hour, minute,past,future)
      },
      clickInterval ({ date,past,future, hasTime, hour, minute }) {
        console.log('------------clicked on a DAyINTERVAL', date,'past=',past,'fut-',future, 'hastime=',hasTime, 'timetoY', hour,minute )
        if (this.showEvent == true) return //we handled it already
        //-------------------------------------------------------------------------
        // Here we are clicking on the intervals on the side. So we have a time
        // And the date closest to the side. usually a Monday
        // We should ALWAYS have a time in here!
        //-------------------------------------------------------------------------
        //create blank event
        this.createBlankEvent(date, hasTime, hour, minute,past,future)
      },
      clickMore ({ date, week }) {
        //-------------------------------------------------------------------------
        // He clicked on that little more button if there are too many events.
        // Take hom to a day
        //-------------------------------------------------------------------------
        console.log('-------------clicked on a MORE',date)
        this.clickDay({date, week})
      },
      clickDate ({ date,past,future, hasTime },e) {
        console.log('do we have an event here?????',e)
        //-------------------------------------------------------------------------
        //We can use this one (big dayofmonth round button click) to switch to dayview
        //Or we can do nothing, except make the currentSelectedDate = date
        //-------------------------------------------------------------------------
        console.log('--------------clicked on a DATE', date,past,future, hasTime )
        this.calValue = date
      },
      clickDay ({ date,week }) {
        //-------------------------------------------------------------------------
        //We can use this to show period times for the day, based on date and weekno
        //If he click on the top white area, or anywhere on a date in monthview we get here.
        //-------------------------------------------------------------------------
        console.log('-----------------clicked on Day:', date, week, this.weekOrDay)
        if (this.weekOrDay == 'month') {
          this.weekOrDay = 'week'
          this.calValue = date
          return
        }
        let clickedDayOfWeek = week.find(e => e.date == date)
        console.log('-----------------clicked on Day (WeekNO):',clickedDayOfWeek.weekday)
        this.calValue = date
        //this.weekOrDay = 'day'
      },
      clickEvent ({ nativeEvent, event }) {
        console.log('----------------clicked on Event:',event.name, event.name.indexOf('day'), event, nativeEvent)
        if (this.showEvent == true) return
        this.selectedEvent = event
        this.selectedElement = nativeEvent.target
        this.showEvent = true
        nativeEvent.stopPropagation()
        // If the event name start with the word day.. we show them info about the day.

        // if (event.name.toLowerCase().indexOf('day') == 0) { alert('day'); return  }

        // const open = () => {
        //   this.selectedEvent = event
        //   this.selectedElement = nativeEvent.target
        //   setTimeout(() => {this.selectedOpen = true}, 20)
        // }
        // if (this.selectedOpen) {
        //   this.selectedOpen = false
        //   setTimeout(open, 10)
        // } else {
        //   open()
        // }
        // nativeEvent.stopPropagation()
      },
      clickDayCategory ({ date,past,future, hasTime }) {
        //-------------------------------------------------------------------------
        //We do not have any day categories - so should never get this one
        //-------------------------------------------------------------------------
        console.log('-------------click on a DAyCATegory', date,past,future, hasTime )
        alert('You clicked on a day category!')
      },
      clickLoad(e) {
        console.log(e,'clickLoad')
      },
      createBlankEvent(date, hasTime, hour, minute,past,future) {
        let gooddate = date
        if (hasTime) gooddate = date + ` ${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`
        this.selectedEvent = {name:'', detail:'', start: gooddate, end: gooddate, type:''}
        this.addingAnEvent(gooddate, date,past,future, hasTime, hour, minute)
      },
      addingAnEvent(gooddate, date,past,future, hasTime, hour, minute) {
        console.log('show him an adding event window',gooddate, date,past,future, hasTime, hour, minute)
        this.showEvent = true
        //alert('add an event!')
      },
      weekOrDayChange() {
          switch (this.weekOrDay) {
          case 'day': this.weekOrDay = 'week';break
          case 'week': this.weekOrDay = 'month';break
          case 'month': this.weekOrDay = 'day';break
          }
      },
      checkChange() {
        if (this.$refs.calendar)  this.$refs.calendar.checkChange()
      },
      updateRange(whatweget) {
         console.info('Range Check', whatweget)

      },
      async loadPeriods() {
        let ts = {}
        ts.task = 'PlainSql'
        ts.api = zmlConfig.apiDKHS
        ts.sql = `select  dt.fulldate startdate
     , dt.dayno
     , per.description
     , concat(dt.fulldate, ' ', per.starttime) startEvt
     , concat(dt.fulldate, ' ', per.endtime) endEvt
     , per.length
     , per.periodname type
     , per.id
     , per.dow
     , if (periodname = 'Break', 'green lighten-1', 'green darken-2') color
FROM dkhs_date dt , dkhs_dayperiod per
WHERE per.dow = dt.dayOfWeek
  AND dt.iddate <  DATE(now() + INTERVAL 30 DAY)
  AND dt.iddate >  DATE(now() - INTERVAL 30 DAY)`
       await zmlFetch(ts, this.assignPerData,  (err) => {console.log('error on PerFetch',err);alert('We go no periods! Contact W.') } )
      },
      assignPerData(response) {
        //console.log('Assign Period Data', response)
        response.forEach(ele => {
          if (ele.startdate) {
             const evt= {
                    name: ele.type
                  , detail: `Day:${ele.dayno} ${ele.description} - ${ele.type} - ${ele.length}M`
                  , start: ele.startEvt
                  , end: ele.endEvt
                  , color: ele.color
                  , type: ele.type
                  , timed: true
                    }
             this.events.push(evt)
          } else {
            console.error(ele.startdate, 'One of our periods does not have a startdate!',ele);
          }
        })
        const evt= {
                    name: 'My Googl Event it'
                  , detail: `Some detaiil to display when we are clicked`
                  , start: '2023-03-14 14:00'
                  , end: '2023-03-16 08:00'
                  , color: 'cyan'
                  , type: 'Werner'
                  , timed: true
                  , eventid: 3
                    }
        this.events.push(evt)

      },
      async loadCalendar() {
        console.log('LoadCalendar:')
        let ts = {}
        ts.task = 'PlainSql'
        ts.api = zmlConfig.apiDKHS
        ts.sql = `select * from (
 select dt.idDate startdate, dt.fulldate enddate, dt.week, dt.dayno dayNo
     ,  concat('day',dayno) event
     , if(dayNo != '0',"School",null) type
     , 'light-blue' color
 FROM dkhs_date dt
 union all
 select dt.idDate,dt.fulldate, dt.week, dt.dayno dayNo
     , hol.holidayname event
     , if(length(hol.holidayname) > 1,"Holiday",null) type
     , 'green'
 FROM dkhs_date dt
 LEFT JOIN dkhs_holiday hol on dt.iddate = hol.iddate
 WHERE dt.idDate <  DATE(now() + INTERVAL 30 DAY)
  AND dt.idDate >  DATE(now() - INTERVAL 30 DAY)
 union all
 select dt.idDate,dt.fulldate, dt.week, dt.dayno dayNo
     , pers.public_preferredname evt
     , if( length(pers.surname) > 4,'Birthday','whatever') type
     , 'indigo'
 FROM dkhs_date dt
 LEFT JOIN dkhs_personel pers on concat(substr(dt.fulldate,9,2), '-', substr(dt.fulldate,6,2)) = concat(substr(pers.IDNumber,3,2), '-', substr(pers.IDNumber,5,2))
where length(pers.IDNumber) > 4
) ev
WHERE ev.startdate <  DATE(now() + INTERVAL 60 DAY)
  AND ev.startdate >  DATE(now() - INTERVAL 60 DAY)
  AND ev.type is not null
ORDER BY ev.startdate`
        await zmlFetch(ts, this.assignCalData,  () => {alert('dfsdfsdfsdf') } )
      },
      assignCalData(response) {
        this.getZml.calendar = response
        console.log(response)
        this.getZml.calendar.forEach(ele => {
          if (ele.startdate) {
             const evt= {name: ele.event
                  , start: ele.enddate
                  , end: ele.enddate
                  , color: ele.color
                  , type: ele.type
                  , timed: false //ele.timed
                    }
             this.events.push(evt)
          } else {
            console.error(ele.startdate, 'One of our event does not have a startdate!',ele);
          }
        })
      },

      setToday () {
        this.calValue = ''
      },
      getCurrentTime () {
        return this.cal ? this.cal.times.now.hour * 60 + this.cal.times.now.minute : 0
      },
      scrollToTime () {
        const time = this.getCurrentTime()
        const first = Math.max(0, time - (time % 30) - 30)

        this.cal.scrollToTime(first)
      },
      updateTime () {
        setInterval(() => this.cal.updateTimes(), 60 * 1000)
      },
      activateCalendar() {
          //if (this.$refs.calendar !== undefined) {
          if (this.calReady == false) {
            console.info('Calendar is Ready?: ' , this.$refs.calendar)
            if (this.$refs.calendar)  this.$refs.calendar.checkChange()
            this.calReady = true
            if (this.$refs.calendar) this.scrollToTime()
            if (this.$refs.calendar) this.updateTime()
          } else {
           console.error('Calendar Ready: ' , this.calReady)
         }

       },
       rinseRepeat() {
         this.activateCalendar()
         if (!this.calReady) {
          setTimeout(() => { this.rinseRepeat() }, 2000)
         }
      },
    },
  created () {
    if (!this.menemonic) {
      if (this.$route.params.menemonic) {
          this.incomingMenemonic = this.$route.params.menemonic.toUpperCase()
      }
    } else {
      this.incomingMenemonic = this.menemonic
    }
    this.today = new Date()
    this.today.setHours(0,0,0,0)
    this.calToday = zDate.format(this.today,'yyyy-MM-dd')
    this.loadCalendar();
    this.loadPeriods();
  },
  mounted () {
    this.$cs.l('MOUNTING KKKKKALENDER-----------------')
  },
  watch: {
  },
}
</script>

<style lang="scss">
.v-current-time {
  height: 2px;
  background-color: #ea4335;
  position: absolute;
  left: -1px;
  right: 0;
  pointer-events: none;

  &.first::before {
    content: '';
    position: absolute;
    background-color: #ea4335;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-top: -5px;
    margin-left: -6.5px;
  }
}
</style>